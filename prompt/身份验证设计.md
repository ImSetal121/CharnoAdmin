# 身份验证设计

## 概述

本项目采用基于Token的身份验证机制，使用Redis存储Token，通过Web过滤器链实现请求认证。系统使用Spring WebFlux响应式框架，所有认证流程均为响应式实现。

## 核心组件

### 1. TokenUtil（Token工具类）

**位置：** `backend-common-security/src/main/java/org/charno/commonsecurity/util/TokenUtil.java`

**职责：** 提供Token的生成、存储、查询、删除功能

**主要方法：**
- `generateToken()`: 生成随机UUID字符串作为Token
- `saveToken(String token, UUID userId)`: 将Token和用户ID存储到Redis，设置7天过期时间
- `getUserIdByToken(String token)`: 根据Token从Redis获取用户ID
- `deleteToken(String token)`: 删除Token（用于登出）

**Token存储格式：**
- Redis Key: `token:{token}`
- Redis Value: 用户ID（UUID字符串）
- 过期时间: 7天（604800秒）

### 2. LoginService（登录业务服务）

**位置：** `backend-system/src/main/java/org/charno/system/service/LoginService.java`

**职责：** 实现登录业务逻辑

**登录流程：**
1. 根据用户名查询用户（账号类型固定为USERNAME）
2. 检查用户状态（必须为ENABLED）
3. 验证密码（使用PasswordUtil）
4. 更新登录时间和IP地址
5. 生成Token（使用TokenUtil.generateToken()）
6. 保存Token到Redis（使用TokenUtil.saveToken()）
7. 返回用户信息和accessToken

**返回格式：**
```java
Map<String, Object> {
    "user": SysUser对象,
    "accessToken": "token字符串"
}
```

### 3. LoginController（登录控制器）

**位置：** `backend-system/src/main/java/org/charno/system/controller/LoginController.java`

**职责：** 处理登录HTTP请求

**接口：** `POST /api/login`

**请求体：**
```json
{
  "username": "用户名",
  "password": "密码"
}
```

**响应格式：**
```json
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "user": {
      "id": "用户ID",
      "accountType": "USERNAME",
      "accountIdentifier": "用户名",
      "nickname": "昵称",
      ...
    },
    "accessToken": "550e8400-e29b-41d4-a716-446655440000"
  },
  "timestamp": "2024-01-01T00:00:00"
}
```

**特点：**
- 自动获取客户端IP地址（支持X-Forwarded-For、X-Real-IP）
- 清除敏感信息（密码哈希）后返回
- 不使用DTO类，使用Map接收和返回数据

### 4. AuthenticationFilter（身份认证过滤器）

**位置：** `backend-common-security/src/main/java/org/charno/commonsecurity/filter/AuthenticationFilter.java`

**职责：** 验证Token并将用户信息添加到请求头

**执行顺序：** Order(-100)，在其他过滤器之前执行

**工作流程：**
1. 从`Authorization`请求头提取Token（支持`Bearer {token}`和直接token两种格式）
2. 如果没有Token，直接放行（不添加用户信息）
3. 使用TokenUtil验证Token并获取用户ID
4. 根据用户ID查询用户信息
5. 检查用户状态，只有ENABLED状态的用户才添加信息
6. 将用户信息添加到请求头，继续过滤器链

**添加到请求头的用户信息：**
- `X-User-Id`: 用户ID（UUID）
- `X-User-Status`: 用户状态
- `X-User-Account-Type`: 账号类型
- `X-User-Account-Identifier`: 账号标识符
- `X-User-Role-Id`: 角色ID

**特点：**
- 不负责拦截请求，只负责添加用户信息
- 如果Token无效或用户状态异常，不添加用户信息但继续放行
- 认证拦截由Spring Security处理

### 5. TokenAuthenticationConverter（Token认证转换器）

**位置：** `backend-common-security/src/main/java/org/charno/commonsecurity/config/TokenAuthenticationConverter.java`

**职责：** 从请求头中提取用户信息并创建Authentication对象

**工作流程：**
1. 从请求头读取`X-User-Id`
2. 如果存在，解析为UUID并创建`TokenAuthenticationToken`对象
3. 如果不存在，返回空Mono（表示未认证）

**特点：**
- 依赖AuthenticationFilter已经添加的用户信息
- 不直接验证Token，只负责创建Authentication对象

### 6. TokenAuthenticationToken（Token认证Token）

**位置：** `backend-common-security/src/main/java/org/charno/commonsecurity/config/TokenAuthenticationToken.java`

**职责：** 自定义Authentication实现，存储Token认证信息

**结构：**
- `principal`: 用户ID（字符串）
- `credentials`: null
- `authorities`: 权限列表（当前为空列表）
- `authenticated`: true（标记为已认证）

### 7. TokenReactiveAuthenticationManager（Token响应式认证管理器）

**位置：** `backend-common-security/src/main/java/org/charno/commonsecurity/config/TokenReactiveAuthenticationManager.java`

**职责：** 验证Authentication对象

**工作流程：**
1. 检查是否为`TokenAuthenticationToken`类型且已认证
2. 如果是，直接返回认证对象
3. 否则返回空（未认证）

**特点：**
- 由于AuthenticationFilter已经验证了Token，这里只需要确认类型即可
- 无需再次验证Token

### 8. SecurityConfig（Spring Security配置）

**位置：** `backend-common-security/src/main/java/org/charno/commonsecurity/config/SecurityConfig.java`

**职责：** 配置Spring Security过滤器链

**配置内容：**
1. 禁用CSRF保护
2. 启用CORS支持
3. 添加自定义认证过滤器（AuthenticationWebFilter）
4. 配置未认证时的处理（返回401错误）
5. 配置请求授权规则

**公开路径（不需要认证）：**
- `/api/test/**` - 测试接口
- `/api/login` - 登录接口
- `/actuator/health` - 健康检查
- `/error` - 错误页面

**其他路径：** 需要认证

**未认证响应：**
```json
{
  "code": 401,
  "message": "未授权，请先登录",
  "timestamp": "2024-01-01T00:00:00"
}
```

## 认证流程

### 登录流程

```mermaid
sequenceDiagram
    participant Client
    participant LoginController
    participant LoginService
    participant TokenUtil
    participant Redis
    participant UserRepository

    Client->>LoginController: POST /api/login {username, password}
    LoginController->>LoginService: login(username, password, ip)
    LoginService->>UserRepository: 查询用户（accountType=USERNAME）
    UserRepository-->>LoginService: 用户信息
    LoginService->>LoginService: 验证密码
    LoginService->>TokenUtil: generateToken()
    TokenUtil-->>LoginService: token字符串
    LoginService->>TokenUtil: saveToken(token, userId)
    TokenUtil->>Redis: SET token:{token} {userId} EX 604800
    Redis-->>TokenUtil: OK
    TokenUtil-->>LoginService: 完成
    LoginService-->>LoginController: {user, accessToken}
    LoginController-->>Client: {code:200, data:{user, accessToken}}
```

### 请求认证流程

```mermaid
sequenceDiagram
    participant Client
    participant AuthenticationFilter
    participant TokenUtil
    participant Redis
    participant UserRepository
    participant TokenAuthConverter
    participant TokenAuthManager
    participant SecurityConfig
    participant Controller

    Client->>AuthenticationFilter: 请求（带Authorization头）
    AuthenticationFilter->>AuthenticationFilter: 提取Token
    alt 有Token
        AuthenticationFilter->>TokenUtil: getUserIdByToken(token)
        TokenUtil->>Redis: GET token:{token}
        Redis-->>TokenUtil: userId
        TokenUtil-->>AuthenticationFilter: userId
        AuthenticationFilter->>UserRepository: findById(userId)
        UserRepository-->>AuthenticationFilter: 用户信息
        AuthenticationFilter->>AuthenticationFilter: 验证用户状态
        alt 用户状态为ENABLED
            AuthenticationFilter->>AuthenticationFilter: 添加用户信息到请求头
        end
    end
    AuthenticationFilter->>TokenAuthConverter: 继续过滤器链
    TokenAuthConverter->>TokenAuthConverter: 从X-User-Id创建Authentication
    TokenAuthConverter->>TokenAuthManager: 验证Authentication
    TokenAuthManager-->>TokenAuthConverter: 返回认证对象
    TokenAuthConverter->>SecurityConfig: 继续过滤器链
    SecurityConfig->>SecurityConfig: 检查授权规则
    alt 已认证
        SecurityConfig->>Controller: 放行
    else 未认证
        SecurityConfig-->>Client: 401未授权
    end
```

## Token格式

### Token生成
- 使用`UUID.randomUUID().toString()`生成
- 格式：`550e8400-e29b-41d4-a716-446655440000`

### Token存储
- Redis Key: `token:{token}`
- Redis Value: 用户ID（UUID字符串）
- 过期时间: 7天（604800秒）

### Token使用
- 客户端在请求头中携带：`Authorization: Bearer {token}` 或 `Authorization: {token}`
- 服务器从Redis查询Token对应的用户ID
- 如果Token不存在或已过期，视为无效Token

## 请求头设计

### 客户端发送的请求头
- `Authorization`: Token字符串（支持Bearer前缀）

### 服务器添加的请求头
- `X-User-Id`: 用户ID（UUID字符串）
- `X-User-Status`: 用户状态（如ENABLED）
- `X-User-Account-Type`: 账号类型（如USERNAME）
- `X-User-Account-Identifier`: 账号标识符
- `X-User-Role-Id`: 角色ID

## 模块依赖关系

```
backend-system-entity (实体 + Repository)
    ↑
    ├── backend-common-security (TokenUtil + AuthenticationFilter)
    └── backend-system (LoginService + LoginController)
```

**依赖说明：**
- `backend-common-security` 依赖 `backend-system-entity`（AuthenticationFilter需要使用SysUserRepository）
- `backend-system` 依赖 `backend-system-entity`（Controller和Service需要使用实体和Repository）
- `backend-system` 依赖 `backend-common-security`（LoginService需要使用TokenUtil）

## 技术特点

1. **响应式编程**：所有组件使用Mono/Flux，支持非阻塞异步处理
2. **职责分离**：
   - AuthenticationFilter：验证Token并添加用户信息（不拦截）
   - Spring Security：处理认证拦截和授权
3. **无状态设计**：Token存储在Redis中，服务器无状态
4. **灵活扩展**：支持多种登录方式（当前实现用户名密码，预留第三方登录接口）
5. **安全性**：
   - 密码使用BCrypt加密存储
   - Token使用随机UUID，难以猜测
   - Token有过期时间，自动失效
   - 用户状态验证，只有ENABLED状态才能认证

## 登录方式设计

### 当前实现
- **用户名密码登录**：`login()` 方法，账号类型固定为USERNAME

### 预留接口
- **Google登录**：`loginByGoogle()` 方法（暂未实现），账号类型固定为GOOGLE
- **微信登录**：`loginByWechat()` 方法（暂未实现），账号类型固定为WECHAT

**设计原则：** 每个登录方法对应一种账户类型

## 错误处理

### 登录失败
- 用户不存在：返回"账号或密码错误"
- 密码错误：返回"账号或密码错误"
- 用户状态异常：返回"用户已被禁用或锁定"

### 认证失败
- Token无效或过期：不添加用户信息，Spring Security返回401
- 用户状态异常：不添加用户信息，Spring Security返回401
- 缺少Token：不添加用户信息，Spring Security返回401

## 使用示例

### Controller中获取用户信息

```java
@GetMapping("/api/admin/users")
public Mono<ApiResponse<List<SysUser>>> getUsers(ServerWebExchange exchange) {
    // 方式1：从请求头获取
    String userId = exchange.getRequest().getHeaders().getFirst("X-User-Id");
    
    // 方式2：从Spring Security获取
    // Authentication authentication = ...;
    // String userId = (String) authentication.getPrincipal();
    
    // 使用用户信息进行业务处理
    ...
}
```

### 前端请求示例

```http
GET /api/admin/users
Authorization: Bearer 550e8400-e29b-41d4-a716-446655440000
```

