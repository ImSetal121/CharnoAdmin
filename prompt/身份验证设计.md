# 身份验证设计

## 概述

本项目采用基于Token的身份验证机制，使用Redis存储Token，通过Web过滤器链实现请求认证。系统使用Spring WebFlux响应式框架，所有认证流程均为响应式实现。

## 核心组件

### 1. TokenUtil（Token工具类）

**位置：** `backend-common-security/src/main/java/org/charno/commonsecurity/util/TokenUtil.java`

**职责：** 提供Token的生成、存储、查询、删除功能

**主要方法：**
- `generateToken()`: 生成随机UUID字符串作为Token
- `saveToken(String token, SysUser user)`: 将Token和完整用户信息（SysUser对象）存储到Redis，设置7天过期时间
- `getUserByToken(String token)`: 根据Token从Redis获取完整用户信息（SysUser对象）
- `deleteToken(String token)`: 删除Token（用于登出）

**Token存储格式：**
- Redis Key: `token:{token}`
- Redis Value: SysUser对象的JSON序列化字符串（使用Jackson序列化）
- 过期时间: 7天（604800秒）

**性能优化：**
- 将用户信息与Token一起存储，避免每次请求都查询PostgreSQL数据库
- 直接从Redis获取用户信息，大幅提升认证性能

### 2. LoginService（登录业务服务）

**位置：** `backend-system/src/main/java/org/charno/system/service/LoginService.java`

**职责：** 实现登录业务逻辑

**登录流程：**
1. 根据用户名查询用户（账号类型固定为USERNAME）
2. 检查用户状态（必须为ENABLED）
3. 验证密码（使用PasswordUtil）
4. 更新登录时间和IP地址
5. 保存用户信息到数据库
6. 生成Token（使用TokenUtil.generateToken()）
7. 保存Token和完整用户信息到Redis（使用TokenUtil.saveToken(token, user)）
8. 返回用户信息和accessToken

**返回格式：**
```java
Map<String, Object> {
    "user": SysUser对象,
    "accessToken": "token字符串"
}
```

### 3. LoginController（登录控制器）

**位置：** `backend-system/src/main/java/org/charno/system/controller/LoginController.java`

**职责：** 处理登录HTTP请求

**接口：** `POST /api/login`

**请求体：**
```json
{
  "username": "用户名",
  "password": "密码"
}
```

**响应格式：**
```json
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "user": {
      "id": "用户ID",
      "accountType": "USERNAME",
      "accountIdentifier": "用户名",
      "nickname": "昵称",
      ...
    },
    "accessToken": "550e8400-e29b-41d4-a716-446655440000"
  },
  "timestamp": "2024-01-01T00:00:00"
}
```

**特点：**
- 自动获取客户端IP地址（支持X-Forwarded-For、X-Real-IP）
- 清除敏感信息（密码哈希）后返回
- 不使用DTO类，使用Map接收和返回数据

### 4. AuthenticationFilter（身份认证过滤器）

**位置：** `backend-common-security/src/main/java/org/charno/commonsecurity/filter/AuthenticationFilter.java`

**职责：** 验证Token并将用户信息添加到请求头

**执行顺序：** Order(-100)，在其他过滤器之前执行

**工作流程：**
1. 从`Authorization`请求头提取Token（支持`Bearer {token}`和直接token两种格式）
2. 如果没有Token，直接放行（不添加用户信息）
3. 使用TokenUtil从Redis获取完整用户信息（SysUser对象）
4. 检查用户状态，只有ENABLED状态的用户才添加信息
5. 将用户信息添加到请求头，继续过滤器链

**性能优化：**
- 直接从Redis获取用户信息，无需查询PostgreSQL数据库
- 减少数据库查询压力，提升响应速度

**添加到请求头的用户信息：**
- `X-User-Id`: 用户ID（UUID）
- `X-User-Status`: 用户状态
- `X-User-Account-Type`: 账号类型
- `X-User-Account-Identifier`: 账号标识符
- `X-User-Role-Code`: 角色代码

**特点：**
- 不负责拦截请求，只负责添加用户信息
- 如果Token无效或用户状态异常，不添加用户信息但继续放行
- 认证拦截由Spring Security处理

### 5. TokenAuthenticationConverter（Token认证转换器）

**位置：** `backend-common-security/src/main/java/org/charno/commonsecurity/config/TokenAuthenticationConverter.java`

**职责：** 从请求头中提取用户信息并创建Authentication对象

**工作流程：**
1. 从请求头读取`X-User-Id`
2. 如果存在，解析为UUID并创建`TokenAuthenticationToken`对象
3. 如果不存在，返回空Mono（表示未认证）

**特点：**
- 依赖AuthenticationFilter已经添加的用户信息
- 不直接验证Token，只负责创建Authentication对象

### 6. TokenAuthenticationToken（Token认证Token）

**位置：** `backend-common-security/src/main/java/org/charno/commonsecurity/config/TokenAuthenticationToken.java`

**职责：** 自定义Authentication实现，存储Token认证信息

**结构：**
- `principal`: 用户ID（字符串）
- `credentials`: null
- `authorities`: 权限列表（当前为空列表）
- `authenticated`: true（标记为已认证）

### 7. TokenReactiveAuthenticationManager（Token响应式认证管理器）

**位置：** `backend-common-security/src/main/java/org/charno/commonsecurity/config/TokenReactiveAuthenticationManager.java`

**职责：** 验证Authentication对象

**工作流程：**
1. 检查是否为`TokenAuthenticationToken`类型且已认证
2. 如果是，直接返回认证对象
3. 否则返回空（未认证）

**特点：**
- 由于AuthenticationFilter已经验证了Token，这里只需要确认类型即可
- 无需再次验证Token

### 8. RedisConfig（Redis配置）

**位置：** `backend-common-redis/src/main/java/org/charno/commonredis/config/RedisConfig.java`

**职责：** 配置ReactiveRedisTemplate支持Object类型存储

**配置内容：**
1. 配置`ReactiveRedisTemplate<String, Object>`，支持Object类型存储
2. 使用`Jackson2JsonRedisSerializer`进行JSON序列化/反序列化
3. 注入Spring Boot的`ObjectMapper`进行序列化配置
4. 配置Redis序列化上下文（Key使用String序列化，Value使用JSON序列化）

**特点：**
- 支持将Java对象（如SysUser）序列化为JSON存储到Redis
- 支持从Redis反序列化JSON为Java对象
- 使用Spring Boot默认的ObjectMapper，确保序列化配置一致

### 9. SecurityConfig（Spring Security配置）

**位置：** `backend-common-security/src/main/java/org/charno/commonsecurity/config/SecurityConfig.java`

**职责：** 配置Spring Security过滤器链

**配置内容：**
1. 禁用CSRF保护
2. 启用CORS支持
3. 添加自定义认证过滤器（AuthenticationWebFilter）
4. 配置未认证时的处理（返回401错误）
5. 配置请求授权规则
6. 支持定制模块通过 `PermitAllPathProvider` 接口注册放行路径

**公开路径（不需要认证）：**
- `/api/login` - 登录接口
- `/api/register` - 注册接口
- 定制模块通过 `PermitAllPathProvider` 接口注册的路径

**其他路径：** 需要认证

**路径注册机制：**
- 系统模块和定制模块可以通过实现 `PermitAllPathProvider` 接口注册需要放行的路径
- 详细说明请参考 [模块注册放行接口规范](./模块注册放行接口规范.md)

**未认证响应：**
```json
{
  "code": 401,
  "message": "未授权，请先登录",
  "timestamp": "2024-01-01T00:00:00"
}
```

### 10. PermitAllPathProvider（路径提供者接口）

**位置：** `backend-common-security/src/main/java/org/charno/commonsecurity/config/PermitAllPathProvider.java`

**职责：** 允许定制模块注册需要放行的路径，无需修改上游代码

**设计目的：**
- 解决下游定制模块需要放行接口但不想修改上游代码的问题
- 通过接口实现可插拔的路径注册机制
- 支持多个定制模块同时注册路径，自动去重

**接口定义：**
```java
public interface PermitAllPathProvider {
    List<String> getPermitAllPaths();
}
```

**使用方式：**

定制模块实现此接口并注册为 Spring Bean：

```java
@Component
public class WechatSecurityPathProvider implements PermitAllPathProvider {
    @Override
    public List<String> getPermitAllPaths() {
        return Arrays.asList(
            "/api/wechat/callback",      // 微信回调接口
            "/api/wechat/verify",         // 微信验证接口
            "/api/wechat/**"              // 通配符支持
        );
    }
}
```

**路径格式支持：**
- **精确路径**：`/api/wechat/callback`
- **通配符路径**：`/api/wechat/**`
- **Ant 风格路径**：`/api/wechat/*/callback`

**工作原理：**
1. `SecurityConfig` 通过构造函数注入 `List<PermitAllPathProvider>`
2. Spring 自动收集所有实现该接口的 Bean
3. 在构建 `SecurityWebFilterChain` 时，调用所有提供者的 `getPermitAllPaths()` 方法
4. 合并上游固定路径和定制模块路径，自动去重
5. 使用 `pathMatchers()` 配置所有路径为 `permitAll()`

**注意事项：**
1. **路径去重**：多个模块可能注册相同路径，SecurityConfig 会自动去重
2. **路径顺序**：Spring Security 按配置顺序匹配，通配符路径应放在精确路径之后
3. **安全性**：定制模块应谨慎注册路径，避免暴露敏感接口
4. **空值处理**：如果 `getPermitAllPaths()` 返回 `null`，会被忽略并记录警告日志
5. **异常处理**：如果获取路径时发生异常，会被捕获并记录错误日志，不影响其他模块

**优势：**
1. **零侵入**：上游代码只需添加接口和修改 SecurityConfig，无需硬编码定制模块路径
2. **可扩展**：支持多个定制模块同时注册路径
3. **类型安全**：使用接口定义，编译时检查
4. **自动发现**：Spring 自动收集所有实现，无需手动注册
5. **向后兼容**：如果没有定制模块实现接口，行为与之前一致

**日志记录：**
- 启动时会记录所有注册的匿名访问路径（INFO 级别）
- 如果提供者返回 `null`，会记录警告日志
- 如果获取路径时发生异常，会记录错误日志

## 认证流程

### 登录流程

```mermaid
sequenceDiagram
    participant Client
    participant LoginController
    participant LoginService
    participant TokenUtil
    participant Redis
    participant UserRepository

    Client->>LoginController: POST /api/login {username, password}
    LoginController->>LoginService: login(username, password, ip)
    LoginService->>UserRepository: 查询用户（accountType=USERNAME）
    UserRepository-->>LoginService: 用户信息
    LoginService->>LoginService: 验证密码
    LoginService->>UserRepository: 保存用户信息
    UserRepository-->>LoginService: 保存后的用户信息
    LoginService->>TokenUtil: generateToken()
    TokenUtil-->>LoginService: token字符串
    LoginService->>TokenUtil: saveToken(token, user)
    TokenUtil->>Redis: SET token:{token} {user对象JSON} EX 604800
    Redis-->>TokenUtil: OK
    TokenUtil-->>LoginService: 完成
    LoginService-->>LoginController: {user, accessToken}
    LoginController-->>Client: {code:200, data:{user, accessToken}}
```

### 请求认证流程

```mermaid
sequenceDiagram
    participant Client
    participant AuthenticationFilter
    participant TokenUtil
    participant Redis
    participant UserRepository
    participant TokenAuthConverter
    participant TokenAuthManager
    participant SecurityConfig
    participant Controller

    Client->>AuthenticationFilter: 请求（带Authorization头）
    AuthenticationFilter->>AuthenticationFilter: 提取Token
    alt 有Token
        AuthenticationFilter->>TokenUtil: getUserByToken(token)
        TokenUtil->>Redis: GET token:{token}
        Redis-->>TokenUtil: 用户对象JSON
        TokenUtil->>TokenUtil: 反序列化为SysUser对象
        TokenUtil-->>AuthenticationFilter: 用户对象
        AuthenticationFilter->>AuthenticationFilter: 验证用户状态
        alt 用户状态为ENABLED
            AuthenticationFilter->>AuthenticationFilter: 添加用户信息到请求头
        end
    end
    AuthenticationFilter->>TokenAuthConverter: 继续过滤器链
    TokenAuthConverter->>TokenAuthConverter: 从X-User-Id创建Authentication
    TokenAuthConverter->>TokenAuthManager: 验证Authentication
    TokenAuthManager-->>TokenAuthConverter: 返回认证对象
    TokenAuthConverter->>SecurityConfig: 继续过滤器链
    SecurityConfig->>SecurityConfig: 检查授权规则
    alt 已认证
        SecurityConfig->>Controller: 放行
    else 未认证
        SecurityConfig-->>Client: 401未授权
    end
```

## Token格式

### Token生成
- 使用`UUID.randomUUID().toString()`生成
- 格式：`550e8400-e29b-41d4-a716-446655440000`

### Token存储
- Redis Key: `token:{token}`
- Redis Value: SysUser对象的JSON序列化字符串（使用Jackson序列化）
- 过期时间: 7天（604800秒）

**存储优化：**
- 存储完整用户信息，避免每次请求都查询PostgreSQL数据库
- 使用Jackson进行JSON序列化，支持复杂对象结构
- SysUser中的roleCode字段直接存储角色代码（String类型）

### Token使用
- 客户端在请求头中携带：`Authorization: Bearer {token}` 或 `Authorization: {token}`
- 服务器从Redis查询Token对应的用户信息（SysUser对象）
- 如果Token不存在或已过期，视为无效Token
- 直接从Redis获取用户信息，无需查询数据库，大幅提升性能

## 请求头设计

### 客户端发送的请求头
- `Authorization`: Token字符串（支持Bearer前缀）

### 服务器添加的请求头
- `X-User-Id`: 用户ID（UUID字符串）
- `X-User-Status`: 用户状态（如ENABLED）
- `X-User-Account-Type`: 账号类型（如USERNAME）
- `X-User-Account-Identifier`: 账号标识符
- `X-User-Role-Code`: 角色代码

## 模块依赖关系

```
backend-system-entity (实体 + Repository)
    ↑
    ├── backend-common-redis (RedisConfig)
    ├── backend-common-security (TokenUtil + AuthenticationFilter)
    └── backend-system (LoginService + LoginController)
```

**依赖说明：**
- `backend-common-redis` 依赖 `spring-boot-starter-data-redis-reactive` 和 `jackson-databind`（配置Redis序列化）
- `backend-common-security` 依赖 `backend-system-entity`（TokenUtil和AuthenticationFilter需要使用SysUser实体）
- `backend-common-security` 依赖 `backend-common-redis`（通过ReactiveRedisTemplate注入，实际由RedisConfig配置）
- `backend-system` 依赖 `backend-system-entity`（Controller和Service需要使用实体和Repository）
- `backend-system` 依赖 `backend-common-security`（LoginService需要使用TokenUtil）

## 技术特点

1. **响应式编程**：所有组件使用Mono/Flux，支持非阻塞异步处理
2. **职责分离**：
   - AuthenticationFilter：验证Token并添加用户信息（不拦截）
   - Spring Security：处理认证拦截和授权
3. **无状态设计**：Token存储在Redis中，服务器无状态
4. **性能优化**：
   - 用户信息与Token一起存储到Redis，避免每次请求都查询PostgreSQL
   - 直接从Redis获取用户信息，大幅提升认证性能
   - 减少数据库查询压力，提升系统吞吐量
5. **灵活扩展**：支持多种登录方式（当前实现用户名密码，预留第三方登录接口）
6. **安全性**：
   - 密码使用BCrypt加密存储
   - Token使用随机UUID，难以猜测
   - Token有过期时间，自动失效
   - 用户状态验证，只有ENABLED状态才能认证

## 登录方式设计

### 当前实现
- **用户名密码登录**：`login()` 方法，账号类型固定为USERNAME

### 预留接口
- **Google登录**：`loginByGoogle()` 方法（暂未实现），账号类型固定为GOOGLE
- **微信登录**：`loginByWechat()` 方法（暂未实现），账号类型固定为WECHAT

**设计原则：** 每个登录方法对应一种账户类型

## 错误处理

### 登录失败
- 用户不存在：返回"账号或密码错误"
- 密码错误：返回"账号或密码错误"
- 用户状态异常：返回"用户已被禁用或锁定"

### 认证失败
- Token无效或过期：不添加用户信息，Spring Security返回401
- 用户状态异常：不添加用户信息，Spring Security返回401
- 缺少Token：不添加用户信息，Spring Security返回401

## 性能优化说明

### 优化前
- 每次请求都需要从PostgreSQL查询用户信息
- 数据库查询成为性能瓶颈
- 高并发场景下数据库压力大

### 优化后
- 用户信息与Token一起存储到Redis（JSON序列化）
- 每次请求直接从Redis获取用户信息，无需查询数据库
- 减少数据库查询：每次请求从1次数据库查询减少到0次
- 提升响应速度：Redis查询比PostgreSQL查询快得多
- 降低数据库压力：减少数据库连接和查询负载

### 注意事项
- 用户信息更新后，Redis中的缓存不会立即更新（需要等待Token过期或重新登录）
- 如果需要实时更新，可以在用户信息更新时同时更新Redis中的Token数据
- Token过期时间为7天，用户信息更新后最多7天生效
- SysUser中的AggregateReference字段通过@JsonIgnore和getRoleId()/setRoleId()方法处理序列化

## 使用示例

### Controller中获取用户信息

```java
@GetMapping("/api/admin/users")
public Mono<ApiResponse<List<SysUser>>> getUsers(ServerWebExchange exchange) {
    // 方式1：从请求头获取
    String userId = exchange.getRequest().getHeaders().getFirst("X-User-Id");
    
    // 方式2：从Spring Security获取
    // Authentication authentication = ...;
    // String userId = (String) authentication.getPrincipal();
    
    // 使用用户信息进行业务处理
    ...
}
```

### 前端请求示例

```http
GET /api/admin/users
Authorization: Bearer 550e8400-e29b-41d4-a716-446655440000
```

