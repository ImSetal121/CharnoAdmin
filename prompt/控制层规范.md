# 控制层（Controller）开发规范

## 核心原则

**控制层负责接收HTTP请求、参数验证、调用Service层，并返回统一格式的响应。控制层分为两类：面向管理的控制类和面向业务的控制类。**

## 控制类分类

### 1. 面向管理的控制类

**类名规范：** 类名需要加上 `Admin` 前缀，如 `AdminSysUserController`

**功能：** 提供CRUD操作及分页条件查询和不分页条件查询

**路径规范：** `/api/admin/{资源名}`

### 2. 面向业务的控制类

**类名规范：** 按业务功能命名，如 `LoginController`、`RegisterController`

**功能：** 实现具体的业务功能接口

**路径规范：** `/api/{业务名}`

## 面向管理的控制类规范

### 角色权限校验

**所有面向管理的控制类必须添加 `@RequiresRole("ADMIN")` 注解**

- 注解位置：类级别（应用于所有方法）
- 导入：`import org.charno.commonsecurity.annotation.RequiresRole;`
- 作用：确保只有ADMIN角色的用户才能访问管理接口
- 校验失败：返回403 Forbidden错误

**示例：**
```java
@RequiresRole("ADMIN")
@RestController
@RequestMapping("/api/admin/entities")
public class AdminEntityController {
    // 所有方法都需要ADMIN角色
}
```

### ✅ 标准模板

```java
package org.charno.system.controller;

import org.charno.commonsecurity.annotation.RequiresRole;
import org.charno.commonweb.response.ApiResponse;
import org.charno.commonweb.response.PageResult;
import org.charno.system.entity.EntityName;
import org.charno.system.repository.EntityRepository;
import org.charno.system.service.EntityService;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.List;

/**
 * 实体名称管理控制器
 * 面向管理的控制类，提供CRUD及条件查询功能
 */
@RequiresRole("ADMIN")
@RestController
@RequestMapping("/api/admin/entities")
public class AdminEntityController {

    private final EntityService entityService;
    private final EntityRepository entityRepository;

    public AdminEntityController(EntityService entityService, EntityRepository entityRepository) {
        this.entityService = entityService;
        this.entityRepository = entityRepository;
    }

    // ==================== CRUD 操作 ====================

    /**
     * 创建实体
     * 
     * 注意：如果实体使用业务主键（如 String code），需要先检查存在性，
     * 然后使用 R2dbcEntityTemplate.insert() 强制插入。
     * 如果使用自动生成的主键（如 UUID），可以直接使用 repository.save()。
     */
    @PostMapping
    public Mono<ApiResponse<EntityName>> create(@RequestBody EntityName entity) {
        return entityRepository.save(entity)
            .map(ApiResponse::success)
            .onErrorResume(e -> Mono.just(ApiResponse.fail("创建失败：" + e.getMessage())));
    }

    /**
     * 根据ID查询实体
     */
    @GetMapping("/{id}")
    public Mono<ApiResponse<EntityName>> getById(@PathVariable ID id) {
        return entityRepository.findById(id)
            .map(ApiResponse::success)
            .switchIfEmpty(Mono.just(ApiResponse.fail("实体不存在")))
            .onErrorResume(e -> Mono.just(ApiResponse.fail("查询失败：" + e.getMessage())));
    }

    /**
     * 更新实体
     * 
     * 注意：必须先查询现有记录，然后更新允许修改的字段，
     * 保留时间戳等字段，避免 save() 尝试 INSERT 导致主键冲突。
     */
    @PutMapping("/{id}")
    public Mono<ApiResponse<EntityName>> update(@PathVariable ID id, @RequestBody EntityName entity) {
        // 先查询现有实体，保留时间戳等字段
        return entityRepository.findById(id)
            .flatMap(existingEntity -> {
                // 更新允许修改的字段
                // ... 根据实际字段更新
                
                // 保留原有的时间戳字段，不更新
                // 更新 updatedAt
                existingEntity.setUpdatedAt(java.time.OffsetDateTime.now());
                
                return entityRepository.save(existingEntity)
                    .map(ApiResponse::success);
            })
            .switchIfEmpty(Mono.just(ApiResponse.fail("实体不存在")))
            .onErrorResume(e -> Mono.just(ApiResponse.fail("更新失败：" + e.getMessage())));
    }

    /**
     * 删除实体
     */
    @DeleteMapping("/{id}")
    public Mono<ApiResponse<Void>> delete(@PathVariable ID id) {
        return entityRepository.deleteById(id)
            .then(Mono.just(ApiResponse.success()))
            .onErrorResume(e -> Mono.just(ApiResponse.fail("删除失败：" + e.getMessage())));
    }

    // ==================== 条件查询 ====================

    /**
     * 不分页条件查询
     */
    @GetMapping("/query")
    public Mono<ApiResponse<List<EntityName>>> query(
            @RequestParam(required = false) String param1,
            @RequestParam(required = false) String param2) {
        return entityService.query(param1, param2)
            .collectList()
            .map(ApiResponse::success)
            .onErrorResume(e -> Mono.just(ApiResponse.fail("查询失败：" + e.getMessage())));
    }

    /**
     * 分页条件查询
     */
    @GetMapping("/query/page")
    public Mono<ApiResponse<PageResult<EntityName>>> queryWithPage(
            @RequestParam(required = false) String param1,
            @RequestParam(required = false) String param2,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(required = false) String sort) {
        
        Pageable pageable = buildPageable(page, size, sort);
        
        return entityService.queryWithPage(param1, param2, pageable)
            .map(ApiResponse::success)
            .onErrorResume(e -> Mono.just(ApiResponse.fail("分页查询失败：" + e.getMessage())));
    }

    /**
     * 构建分页参数
     */
    private Pageable buildPageable(int page, int size, String sort) {
        if (sort != null && !sort.isEmpty()) {
            String[] sortParts = sort.split(",");
            if (sortParts.length == 2) {
                String field = sortParts[0].trim();
                Sort.Direction direction = "desc".equalsIgnoreCase(sortParts[1].trim()) 
                    ? Sort.Direction.DESC 
                    : Sort.Direction.ASC;
                return PageRequest.of(page, size, Sort.by(direction, field));
            }
        }
        // 默认按创建时间降序
        return PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "createdAt"));
    }
}
```

## CRUD 操作规范

### ⚠️ 重要：主键类型与 R2DBC save() 方法行为

**R2DBC 的 `save()` 方法行为：**
- 当主键为 `null` 时，执行 **INSERT** 操作
- 当主键不为 `null` 时，可能先尝试 **UPDATE**，如果记录不存在会报错

**主键类型分类：**

1. **自动生成的主键**（如 `UUID`、自增 `Long`）
   - 创建时前端通常不传递主键（为 `null`）
   - 可以直接使用 `repository.save(entity)` 进行创建

2. **业务主键**（如 `String code`、自定义业务标识）
   - 创建时前端必须传递主键值
   - **必须**先检查是否存在，然后使用 `R2dbcEntityTemplate.insert()` 强制 INSERT

### 1. 创建（Create）

#### 情况1：自动生成的主键（UUID、自增ID等）

```java
@PostMapping
public Mono<ApiResponse<Entity>> create(@RequestBody Entity entity) {
    // 主键为 null，save() 会自动执行 INSERT
    return repository.save(entity)
        .map(ApiResponse::success)
        .onErrorResume(e -> Mono.just(ApiResponse.fail("创建失败：" + e.getMessage())));
}
```

#### 情况2：业务主键（String code 等）

**需要注入 `R2dbcEntityTemplate`：**

```java
@RequiresRole("ADMIN")
@RestController
@RequestMapping("/api/admin/entities")
public class AdminEntityController {
    
    private final EntityService entityService;
    private final EntityRepository entityRepository;
    private final R2dbcEntityTemplate template;  // 需要注入
    
    public AdminEntityController(EntityService entityService, 
                                 EntityRepository entityRepository,
                                 R2dbcEntityTemplate template) {
        this.entityService = entityService;
        this.entityRepository = entityRepository;
        this.template = template;
    }
    
    @PostMapping
    public Mono<ApiResponse<Entity>> create(@RequestBody Entity entity) {
        // 检查业务主键是否已存在
        if (entity.getCode() == null || entity.getCode().isEmpty()) {
            return Mono.just(ApiResponse.fail("业务主键不能为空"));
        }
        
        return entityRepository.existsById(entity.getCode())
            .flatMap(exists -> {
                if (exists) {
                    return Mono.just(ApiResponse.fail("业务主键已存在：" + entity.getCode()));
                }
                // 设置创建时间
                if (entity.getCreatedAt() == null) {
                    entity.setCreatedAt(java.time.OffsetDateTime.now());
                }
                // 使用 insert() 方法强制插入新记录，避免 save() 尝试更新
                return template.insert(entity)
                    .map(ApiResponse::success);
            })
            .onErrorResume(e -> Mono.just(ApiResponse.fail("创建失败：" + e.getMessage())));
    }
}
```

**导入语句：**
```java
import org.springframework.data.r2dbc.core.R2dbcEntityTemplate;
import java.time.OffsetDateTime;
```

### 2. 查询（Read）

```java
@GetMapping("/{id}")
public Mono<ApiResponse<Entity>> getById(@PathVariable ID id) {
    return repository.findById(id)
        .map(ApiResponse::success)
        .switchIfEmpty(Mono.just(ApiResponse.fail("实体不存在")))
        .onErrorResume(e -> Mono.just(ApiResponse.fail("查询失败：" + e.getMessage())));
}
```

### 3. 更新（Update）

**⚠️ 重要：更新操作必须先查询现有记录**

直接使用 `save()` 可能会尝试 INSERT 而不是 UPDATE，导致主键冲突。正确的做法是：

```java
@PutMapping("/{id}")
public Mono<ApiResponse<Entity>> update(@PathVariable ID id, @RequestBody Entity entity) {
    // 先查询现有实体，保留时间戳等字段
    return repository.findById(id)
        .flatMap(existingEntity -> {
            // 更新允许修改的字段
            if (entity.getField1() != null) {
                existingEntity.setField1(entity.getField1());
            }
            if (entity.getField2() != null) {
                existingEntity.setField2(entity.getField2());
            }
            // ... 更新其他允许修改的字段
            
            // 保留原有的时间戳字段（createdAt、lastLoginAt 等），不更新
            // 保留密码相关字段，不更新（密码修改应通过专门的接口）
            
            // 更新 updatedAt
            existingEntity.setUpdatedAt(java.time.OffsetDateTime.now());
            
            // 保存更新后的实体
            return repository.save(existingEntity)
                .map(ApiResponse::success);
        })
        .switchIfEmpty(Mono.just(ApiResponse.fail("实体不存在")))
        .onErrorResume(e -> Mono.just(ApiResponse.fail("更新失败：" + e.getMessage())));
}
```

**导入语句：**
```java
import java.time.OffsetDateTime;
```

### 4. 删除（Delete）

```java
@DeleteMapping("/{id}")
public Mono<ApiResponse<Void>> delete(@PathVariable ID id) {
    return repository.deleteById(id)
        .then(Mono.just(ApiResponse.success()))
        .onErrorResume(e -> Mono.just(ApiResponse.fail("删除失败：" + e.getMessage())));
}
```

## 条件查询规范

### 1. 不分页条件查询

- **路径：** `GET /api/admin/{资源名}/query`
- **参数：** 所有查询条件均为可选（`@RequestParam(required = false)`）
- **返回：** `Mono<ApiResponse<List<Entity>>>`
- **实现：** 调用 Service 层的 `query()` 方法，使用 `collectList()` 收集结果

### 2. 分页条件查询

- **路径：** `GET /api/admin/{资源名}/query/page`
- **参数：** 查询条件 + `page`（默认0）、`size`（默认10）、`sort`（可选）
- **返回：** `Mono<ApiResponse<PageResult<Entity>>>`
- **实现：** 调用 Service 层的 `queryWithPage()` 方法，使用 `buildPageable()` 构建分页参数
- **说明：** Service 层返回 `Mono<PageResult<Entity>>`，Controller 直接使用 `map(ApiResponse::success)` 包装返回

### 3. 分页参数构建

```java
private Pageable buildPageable(int page, int size, String sort) {
    if (sort != null && !sort.isEmpty()) {
        String[] sortParts = sort.split(",");
        if (sortParts.length == 2) {
            String field = sortParts[0].trim();
            Sort.Direction direction = "desc".equalsIgnoreCase(sortParts[1].trim()) 
                ? Sort.Direction.DESC 
                : Sort.Direction.ASC;
            return PageRequest.of(page, size, Sort.by(direction, field));
        }
    }
    // 默认按创建时间降序
    return PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "createdAt"));
}
```

**排序参数格式：** `field,asc` 或 `field,desc`，如 `createdAt,desc`

## 响应格式规范

### 统一使用 ApiResponse

```java
// 成功响应（带数据）
ApiResponse.success(data)

// 成功响应（无数据）
ApiResponse.success()

// 失败响应
ApiResponse.fail("错误消息")
```

### 返回类型

- **单个实体：** `Mono<ApiResponse<Entity>>`
- **实体列表：** `Mono<ApiResponse<List<Entity>>>`
- **无返回值：** `Mono<ApiResponse<Void>>`

## 错误处理规范

### 使用 onErrorResume 处理异常

```java
return repository.save(entity)
    .map(ApiResponse::success)
    .onErrorResume(e -> Mono.just(ApiResponse.fail("操作失败：" + e.getMessage())));
```

### 空值处理

```java
return repository.findById(id)
    .map(ApiResponse::success)
    .switchIfEmpty(Mono.just(ApiResponse.fail("实体不存在")))
    .onErrorResume(e -> Mono.just(ApiResponse.fail("查询失败：" + e.getMessage())));
```

## 面向业务的控制类规范

### ✅ 标准模板

```java
package org.charno.system.controller;

import org.charno.commonweb.response.ApiResponse;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

/**
 * 业务功能控制器
 * 面向业务的控制类，实现具体的业务功能
 */
@RestController
@RequestMapping("/api/business")
public class BusinessController {

    private final BusinessService businessService;

    public BusinessController(BusinessService businessService) {
        this.businessService = businessService;
    }

    /**
     * 业务功能接口
     */
    @PostMapping("/action")
    public Mono<ApiResponse<Result>> action(@RequestBody Request request) {
        return businessService.doAction(request)
            .map(ApiResponse::success)
            .onErrorResume(e -> Mono.just(ApiResponse.fail("操作失败：" + e.getMessage())));
    }
}
```

## 依赖注入规范

### 必需依赖

```java
@RestController
public class AdminEntityController {
    // Service - 用于条件查询和业务逻辑
    private final EntityService entityService;
    
    // Repository - 用于CRUD操作
    private final EntityRepository entityRepository;
    
    public AdminEntityController(EntityService entityService, EntityRepository entityRepository) {
        this.entityService = entityService;
        this.entityRepository = entityRepository;
    }
}
```

### 可选依赖（根据主键类型决定）

**如果实体使用业务主键（如 String code），需要注入 `R2dbcEntityTemplate`：**

```java
@RestController
public class AdminEntityController {
    private final EntityService entityService;
    private final EntityRepository entityRepository;
    private final R2dbcEntityTemplate template;  // 业务主键时需要
    
    public AdminEntityController(EntityService entityService, 
                                 EntityRepository entityRepository,
                                 R2dbcEntityTemplate template) {
        this.entityService = entityService;
        this.entityRepository = entityRepository;
        this.template = template;
    }
}
```

**导入语句：**
```java
import org.springframework.data.r2dbc.core.R2dbcEntityTemplate;
```

## ❌ 禁止事项

1. **禁止在Controller中实现业务逻辑**
   ```java
   // ❌ 错误
   @PostMapping
   public Mono<ApiResponse<Entity>> create(@RequestBody Entity entity) {
       // 业务验证逻辑应在Service层
       if (entity.getStatus() == null) {
           return Mono.just(ApiResponse.fail("状态不能为空"));
       }
       return repository.save(entity).map(ApiResponse::success);
   }
   ```

2. **禁止直接操作数据库**
   ```java
   // ❌ 错误：Controller不应直接调用Repository的复杂方法
   // 应通过Service层调用
   ```

3. **禁止返回原始类型**
   ```java
   // ❌ 错误
   public Mono<Entity> getById(@PathVariable ID id) {
       return repository.findById(id);
   }
   
   // ✅ 正确
   public Mono<ApiResponse<Entity>> getById(@PathVariable ID id) {
       return repository.findById(id)
           .map(ApiResponse::success);
   }
   ```

## ✅ 检查清单

- [ ] 管理控制类类名以 `Admin` 前缀开头
- [ ] 添加了 `@RequiresRole("ADMIN")` 注解（类级别）
- [ ] 导入了 `org.charno.commonsecurity.annotation.RequiresRole`
- [ ] 路径使用 `/api/admin/{资源名}` 格式
- [ ] 提供完整的CRUD操作（POST, GET/{id}, PUT/{id}, DELETE/{id}）
- [ ] 提供条件查询接口（/query 和 /query/page）
- [ ] 所有方法返回 `Mono<ApiResponse<T>>`
- [ ] 使用 `onErrorResume` 处理异常
- [ ] 使用 `switchIfEmpty` 处理空值
- [ ] 查询参数使用 `@RequestParam(required = false)`
- [ ] 分页参数有默认值（page=0, size=10）
- [ ] 实现了 `buildPageable()` 私有方法
- [ ] **如果使用业务主键，创建操作已检查存在性并使用 `template.insert()`**
- [ ] **更新操作已先查询现有记录，然后更新字段并保留时间戳**

## 角色权限说明

### @RequiresRole注解

**位置：** `backend-common-security/src/main/java/org/charno/commonsecurity/annotation/RequiresRole.java`

**功能：** 用于在Controller类或方法上标注需要的角色权限

**使用方式：**

1. **类级别使用（推荐用于Admin控制器）**
   ```java
   @RequiresRole("ADMIN")
   @RestController
   @RequestMapping("/api/admin/entities")
   public class AdminEntityController {
       // 所有方法都需要ADMIN角色
   }
   ```

2. **方法级别使用**
   ```java
   @RestController
   @RequestMapping("/api/business")
   public class BusinessController {
       
       @RequiresRole("ADMIN")
       @DeleteMapping("/{id}")
       public Mono<ApiResponse<Void>> delete(@PathVariable UUID id) {
           // 只有ADMIN角色可以访问
       }
       
       @RequiresRole({"ADMIN", "MANAGER"})
       @PutMapping("/{id}")
       public Mono<ApiResponse<Entity>> update(@PathVariable UUID id, @RequestBody Entity entity) {
           // ADMIN或MANAGER角色可以访问
       }
   }
   ```

**支持多个角色（OR关系）：**
```java
@RequiresRole({"ADMIN", "MANAGER"})  // 满足任意一个角色即可
```

**校验流程：**
1. RoleCheckWebFilter检查Controller方法上的@RequiresRole注解
2. 从请求头获取X-User-Role-Code
3. 直接使用roleCode校验是否匹配注解中要求的角色
4. 校验用户的角色code是否匹配注解中要求的角色
5. 如果匹配，放行；如果不匹配，返回403 Forbidden

**错误响应：**
```json
{
  "code": 403,
  "message": "禁止访问：需要角色权限",
  "timestamp": "2024-01-01T00:00:00"
}
```

## 优势

1. **结构清晰**：管理类和业务类分离
2. **统一接口**：所有管理类提供相同的CRUD和查询接口
3. **统一响应**：使用 ApiResponse 统一响应格式
4. **错误处理**：统一的错误处理机制
5. **易于扩展**：业务控制类可按需添加
6. **权限控制**：通过@RequiresRole注解实现细粒度的角色权限控制

