# 启动模块（ModuleInitialization）开发规范

## 核心原则

**启动模块负责在应用启动时执行模块初始化工作，包括配置初始化、数据初始化等。同时，启动模块还可以实现 `PermitAllPathProvider` 接口，注册模块需要放行的路径。**

## 类命名规范

**类名统一为：** `ModuleInitialization`

**位置：** `src/main/java/org/charno/{模块包名}/ModuleInitialization.java`

**示例：**
- 系统模块：`org.charno.system.ModuleInitialization`
- 定制模块：`org.charno.custom.wechatcustomer.ModuleInitialization`

## 接口实现规范

### 必需接口

1. **ApplicationRunner** - 用于应用启动时执行初始化逻辑
2. **PermitAllPathProvider** - 用于注册需要放行的路径（如果模块有需要放行的接口）

### 标准模板

```java
package org.charno.custom.wechatcustomer;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import config.org.charno.common.security.PermitAllPathProvider;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.List;

/**
 * 微信客服模块初始化
 * 负责检查并创建微信企业ID和密钥相关配置项
 */
@Slf4j
@Component("wechatCustomerModuleInitialization")  // 指定唯一的 Bean 名称，避免冲突
@RequiredArgsConstructor
public class ModuleInitialization implements ApplicationRunner, PermitAllPathProvider {

    // 依赖注入（使用 @RequiredArgsConstructor）
    private final SysConfigRepository configRepository;
    private final R2dbcEntityTemplate template;

    @Override
    public void run(ApplicationArguments args) {
        log.info("开始初始化微信客服模块配置...");
        
        // 执行初始化逻辑（响应式编程）
        initializeConfig()
            .doOnSuccess(v -> log.info("微信客服模块配置初始化完成"))
            .doOnError(e -> log.error("微信客服模块配置初始化失败", e))
            .subscribe();
    }

    /**
     * 获取微信客服模块需要放行的路径
     * 注册企业微信回调接口，允许匿名访问
     * 
     * @return 路径列表
     */
    @Override
    public List<String> getPermitAllPaths() {
        return Arrays.asList(
            "/api/wechat/callback/**"  // 企业微信回调接口
        );
    }
    
    // 私有初始化方法
    private Mono<Void> initializeConfig() {
        // TODO: 实现初始化逻辑
        return Mono.empty();
    }
}
```

## 注解规范

### 必需注解

1. **@Component** - 注册为 Spring Bean
   - 可以指定 Bean 名称，避免与其他模块冲突
   - 示例：`@Component("wechatCustomerModuleInitialization")`

2. **@Slf4j** - 日志记录（Lombok）
   - 自动生成 `log` 字段

3. **@RequiredArgsConstructor** - 构造函数注入（Lombok）
   - 自动生成包含所有 `final` 字段的构造函数

### 可选注解

- 如果不需要注册路径，可以不实现 `PermitAllPathProvider` 接口
- 如果不需要初始化逻辑，`run()` 方法可以为空

## 方法实现规范

### 1. run() 方法

**职责：** 执行模块启动时的初始化逻辑

**特点：**
- 使用响应式编程（Mono/Flux）
- 使用 `subscribe()` 触发执行
- 添加日志记录（开始、成功、失败）
- 使用 `doOnSuccess()` 和 `doOnError()` 处理结果

**示例：**
```java
@Override
public void run(ApplicationArguments args) {
    log.info("开始初始化模块配置...");
    
    initializeConfig()
        .doOnSuccess(v -> log.info("模块配置初始化完成"))
        .doOnError(e -> log.error("模块配置初始化失败", e))
        .subscribe();
}
```

### 2. getPermitAllPaths() 方法

**职责：** 返回模块需要放行的路径列表

**返回值：**
- 不能返回 `null`，如果不需要注册路径，返回空列表
- 支持精确路径和通配符路径

**示例：**
```java
@Override
public List<String> getPermitAllPaths() {
    return Arrays.asList(
        "/api/wechat/callback/**"  // 通配符路径
    );
}
```

**如果不需要注册路径：**
```java
@Override
public List<String> getPermitAllPaths() {
    return Collections.emptyList();
}
```

## 初始化逻辑规范

### 常见初始化场景

1. **配置项初始化**
   - 检查配置项是否存在
   - 如果不存在，创建默认配置项
   - 使用 `R2dbcEntityTemplate` 或 `Repository` 操作数据库

2. **数据初始化**
   - 初始化默认数据
   - 检查并创建必要的记录

3. **缓存预热**
   - 预加载常用数据到缓存

### 响应式编程规范

**所有数据库操作应使用响应式方式：**

```java
private Mono<Void> initializeConfig(String key, String description) {
    return configRepository.existsById(key)
        .flatMap(exists -> {
            if (exists) {
                log.debug("配置项已存在: {}", key);
                return Mono.empty();
            } else {
                log.info("创建配置项: {} - {}", key, description);
                SysConfig config = new SysConfig();
                config.setKey(key);
                config.setValue("");
                config.setDescription(description);
                
                return template.insert(config)
                    .doOnSuccess(v -> log.info("成功创建配置项: {}", key))
                    .doOnError(e -> log.error("创建配置项失败: {}", key, e))
                    .then();
            }
        });
}
```

## Bean 名称规范

**为避免多个模块的 `ModuleInitialization` Bean 冲突，建议指定唯一的 Bean 名称：**

```java
@Component("wechatCustomerModuleInitialization")  // 使用模块名作为 Bean 名称
```

**命名规则：**
- 格式：`{模块名}ModuleInitialization`
- 示例：`wechatCustomerModuleInitialization`、`paymentModuleInitialization`

## 日志记录规范

### 日志级别

- **INFO**：模块初始化开始和完成
- **DEBUG**：配置项已存在等非关键信息
- **ERROR**：初始化失败

### 日志内容

```java
log.info("开始初始化{模块名}配置...");
log.info("创建{配置项名}: {} - {}", key, description);
log.debug("配置项已存在: {}", key);
log.info("成功创建配置项: {}", key);
log.error("创建配置项失败: {}", key, e);
log.info("{模块名}配置初始化完成");
log.error("{模块名}配置初始化失败", e);
```

## 依赖注入规范

### 使用构造函数注入

**推荐使用 `@RequiredArgsConstructor`（Lombok）：**

```java
@RequiredArgsConstructor
public class ModuleInitialization implements ApplicationRunner, PermitAllPathProvider {
    private final SysConfigRepository configRepository;
    private final R2dbcEntityTemplate template;
}
```

### 常用依赖

- `SysConfigRepository` - 系统配置 Repository
- `R2dbcEntityTemplate` - R2DBC 模板，用于数据库操作
- 其他业务 Repository 或 Service

## 完整示例

### 示例1：系统模块（简单）

```java
package org.charno.system;

import config.org.charno.common.security.PermitAllPathProvider;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.List;

@Component
public class ModuleInitialization implements ApplicationRunner, PermitAllPathProvider {
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        // 系统模块初始化逻辑
    }
    
    @Override
    public List<String> getPermitAllPaths() {
        return Arrays.asList(
                "/api/login",
                "/api/register"
        );
    }
}
```

### 示例2：定制模块（完整）

```java
package org.charno.custom.wechatcustomer;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import config.org.charno.common.security.PermitAllPathProvider;
import org.charno.systementity.entity.SysConfig;
import org.charno.systementity.repository.SysConfigRepository;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.data.r2dbc.core.R2dbcEntityTemplate;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.util.Arrays;
import java.util.List;

@Slf4j
@Component("wechatCustomerModuleInitialization")
@RequiredArgsConstructor
public class ModuleInitialization implements ApplicationRunner, PermitAllPathProvider {

    private final SysConfigRepository configRepository;
    private final R2dbcEntityTemplate template;

    private static final String WECHAT_CORP_ID_KEY = "wechat.corp.id";
    private static final String WECHAT_CORP_SECRET_KEY = "wechat.corp.secret";

    @Override
    public void run(ApplicationArguments args) {
        log.info("开始初始化微信客服模块配置...");
        
        initializeWechatConfig(WECHAT_CORP_ID_KEY, "企业微信企业ID", "请在企业管理后台获取企业ID")
            .then(initializeWechatConfig(WECHAT_CORP_SECRET_KEY, "企业微信企业密钥", "请在企业管理后台获取企业密钥"))
            .doOnSuccess(v -> log.info("微信客服模块配置初始化完成"))
            .doOnError(e -> log.error("微信客服模块配置初始化失败", e))
            .subscribe();
    }

    @Override
    public List<String> getPermitAllPaths() {
        return Arrays.asList(
            "/api/wechat/callback/**"
        );
    }

    private Mono<Void> initializeWechatConfig(String key, String description, String hint) {
        return configRepository.existsById(key)
            .flatMap(exists -> {
                if (exists) {
                    log.debug("配置项已存在: {}", key);
                    return Mono.empty();
                } else {
                    log.info("创建微信配置项: {} - {}", key, description);
                    SysConfig config = new SysConfig();
                    config.setKey(key);
                    config.setValue("");
                    config.setDescription(description + "。提示：" + hint);
                    
                    return template.insert(config)
                        .doOnSuccess(v -> log.info("成功创建配置项: {}", key))
                        .doOnError(e -> log.error("创建配置项失败: {}", key, e))
                        .then();
                }
            });
    }
}
```

## 注意事项

1. **Bean 名称冲突**：多个模块都使用 `ModuleInitialization` 类名，必须指定唯一的 Bean 名称
2. **响应式编程**：所有数据库操作必须使用响应式方式（Mono/Flux）
3. **错误处理**：使用 `doOnError()` 处理异常，避免异常导致应用启动失败
4. **日志记录**：添加适当的日志，便于排查问题
5. **路径注册**：如果不需要注册路径，`getPermitAllPaths()` 返回空列表，不能返回 `null`
6. **初始化顺序**：多个模块的初始化顺序不确定，不要依赖其他模块的初始化结果

## 检查清单

创建新的启动模块时，请检查：

- [ ] 类名统一为 `ModuleInitialization`
- [ ] 实现了 `ApplicationRunner` 接口
- [ ] 如果模块有需要放行的接口，实现了 `PermitAllPathProvider` 接口
- [ ] 使用 `@Component` 注解，并指定唯一的 Bean 名称
- [ ] 使用 `@Slf4j` 注解进行日志记录
- [ ] 使用 `@RequiredArgsConstructor` 进行依赖注入
- [ ] `run()` 方法使用响应式编程，添加日志和错误处理
- [ ] `getPermitAllPaths()` 方法不返回 `null`
- [ ] 所有数据库操作使用响应式方式
- [ ] 添加了适当的日志记录

## 相关文档

- [模块注册放行接口规范](./模块注册放行接口规范.md) - 了解 PermitAllPathProvider 接口的详细说明
- [业务层规范](./业务层规范.md) - 了解响应式编程规范
- [持久层规范](./持久层规范.md) - 了解 Repository 和 R2DBC 使用规范

