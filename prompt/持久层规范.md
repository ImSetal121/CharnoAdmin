# 持久层（Repository）开发规范

## 核心原则

**Repository 层仅提供增删查改（CRUD）原子操作，不包含任何查询逻辑和业务逻辑。**

## Repository 接口规范

### ✅ 标准模板

```java
package org.charno.system.repository;

import org.charno.system.entity.EntityName;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import org.springframework.data.repository.reactive.ReactiveSortingRepository;

/**
 * 实体名称 Repository
 * Spring Data R2DBC 响应式持久层接口
 */
public interface EntityNameRepository extends ReactiveCrudRepository<EntityName, ID>, 
                                           ReactiveSortingRepository<EntityName, ID> {
    // 不定义任何自定义方法
}
```

### ✅ 提供的基础方法

**ReactiveCrudRepository：**
- `save(T)` / `saveAll()` - 保存
- `findById(ID)` / `findAll()` - 查询
- `existsById(ID)` - 存在性检查
- `count()` - 计数
- `deleteById(ID)` / `delete(T)` / `deleteAll()` - 删除

**ReactiveSortingRepository：**
- `findAll(Sort)` - 排序查询

## 查询逻辑实现位置

**所有查询逻辑必须在 Service 层实现，使用 R2dbcEntityTemplate。**

### Service 层实现示例

```java
@Service
@RequiredArgsConstructor
public class EntityService {
    private final R2dbcEntityTemplate template;
    private final EntityRepository repository;
    
    // 单条件查询
    public Flux<Entity> findByStatus(String status) {
        return template.select(Entity.class)
            .matching(Query.query(Criteria.where("status").is(status)))
            .all();
    }
    
    // 多条件查询
    public Mono<Entity> findByAccount(String type, String identifier) {
        return template.select(Entity.class)
            .matching(Query.query(
                Criteria.where("type").is(type)
                    .and("identifier").is(identifier)
            ))
            .one();
    }
    
    // 分页查询
    public Flux<Entity> findByStatusWithPage(String status, Pageable pageable) {
        return template.select(Entity.class)
            .matching(Query.query(Criteria.where("status").is(status))
                .with(pageable))
            .all();
    }
    
    // 模糊查询
    public Flux<Entity> findByNicknameContaining(String nickname) {
        return template.select(Entity.class)
            .matching(Query.query(
                Criteria.where("nickname").like("%" + nickname + "%")
            ))
            .all();
    }
    
    // 空值判断（业务逻辑）
    public Flux<Entity> findActive() {
        return template.select(Entity.class)
            .matching(Query.query(Criteria.where("deletedAt").isNull()))
            .all();
    }
}
```

## ❌ 禁止事项

1. **禁止定义自定义查询方法**
   ```java
   // ❌ 错误
   Flux<Entity> findByStatus(String status);
   ```

2. **禁止使用 @Query 注解**
   ```java
   // ❌ 错误
   @Query("SELECT * FROM entity WHERE status = :status")
   Flux<Entity> findByStatus(String status);
   ```

3. **禁止包含业务逻辑**
   ```java
   // ❌ 错误
   Flux<Entity> findActive(); // 业务逻辑应在 Service 层
   ```

## ✅ 检查清单

- [ ] Repository 只继承 `ReactiveCrudRepository` 和 `ReactiveSortingRepository`
- [ ] 没有定义任何自定义方法
- [ ] 没有使用 `@Query` 注解
- [ ] 所有查询逻辑在 Service 层实现
- [ ] Service 层注入了 `R2dbcEntityTemplate`

## 优势

1. **职责单一**：Repository 只负责数据访问原子操作
2. **业务集中**：查询逻辑集中在 Service 层，便于维护
3. **灵活性强**：Service 层可自由组合查询条件
4. **代码简洁**：Repository 接口简洁明了

